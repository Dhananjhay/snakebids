"""
This type stub file was generated by pyright.
"""

"""
    inflect.py: correctly generate plurals, ordinals, indefinite articles;
                convert numbers to words
    Copyright (C) 2010 Paul Dyson

    Based upon the Perl module Lingua::EN::Inflect by Damian Conway.

    The original Perl module Lingua::EN::Inflect by Damian Conway is
    available from http://search.cpan.org/~dconway/

    This module can be downloaded at http://pypi.org/project/inflect

methods:
          classical inflect
          plural plural_noun plural_verb plural_adj singular_noun no num a an
          compare compare_nouns compare_verbs compare_adjs
          present_participle
          ordinal
          number_to_words
          join
          defnoun defverb defadj defa defan

    INFLECTIONS:    classical inflect
          plural plural_noun plural_verb plural_adj singular_noun compare
          no num a an present_participle

    PLURALS:   classical inflect
          plural plural_noun plural_verb plural_adj singular_noun no num
          compare compare_nouns compare_verbs compare_adjs

    COMPARISONS:    classical
          compare compare_nouns compare_verbs compare_adjs

    ARTICLES:   classical inflect num a an

    NUMERICAL:      ordinal number_to_words

    USER_DEFINED:   defnoun defverb defadj defa defan

Exceptions:
 UnknownClassicalModeError
 BadNumValueError
 BadChunkingOptionError
 NumOutOfRangeError
 BadUserDefinedPatternError
 BadRcFileError
 BadGenderError

"""

class UnknownClassicalModeError(Exception): ...
class BadNumValueError(Exception): ...
class BadChunkingOptionError(Exception): ...
class NumOutOfRangeError(Exception): ...
class BadUserDefinedPatternError(Exception): ...
class BadRcFileError(Exception): ...
class BadGenderError(Exception): ...

__version__ = ...
STDOUT_ON = ...

def print3(txt): ...
def enclose(s): ...
def joinstem(cutpoint=..., words=...):  # -> str:
    """
    join stem of each word in words into a string for regex
    each word is truncated at cutpoint
    cutpoint is usually negative indicating the number of letters to remove
    from the end of each word

    e.g.
    joinstem(-2, ["ephemeris", "iris", ".*itis"]) returns
    (?:ephemer|ir|.*it)

    """
    ...

def bysize(words):  # -> dict[Unknown, Unknown]:
    """
    take a list of words and return a dict of sets sorted by word length
    e.g.
    ret[3]=set(['ant', 'cat', 'dog', 'pig'])
    ret[4]=set(['frog', 'goat'])
    ret[5]=set(['horse'])
    ret[8]=set(['elephant'])
    """
    ...

def make_pl_si_lists(
    lst, plending, siendingsize, dojoinstem=...
):  # -> tuple[list[Unknown], dict[Unknown, Unknown], dict[Unknown, Unknown], str] | tuple[list[Unknown], dict[Unknown, Unknown], dict[Unknown, Unknown]]:
    """
    given a list of singular words: lst
    an ending to append to make the plural: plending
    the number of characters to remove from the singular
        before appending plending: siendingsize
    a flag whether to create a joinstem: dojoinstem

    return:
    a list of pluralised words: si_list (called si because this is what you need to
                                         look for to make the singular)
    the pluralised words as a dict of sets sorted by word length: si_bysize
    the singular words as a dict of sets sorted by word length: pl_bysize
    if dojoinstem is True: a regular expression that matches any of the stems: stem
    """
    ...

pl_sb_irregular_s = ...
pl_sb_irregular = ...
pl_sb_irregular_caps = ...
pl_sb_irregular_compound = ...
si_sb_irregular = ...
keys = ...
si_sb_irregular_caps = ...
si_sb_irregular_compound = ...
keys = ...
pl_sb_z_zes_list = ...
pl_sb_z_zes_bysize = ...
pl_sb_ze_zes_list = ...
pl_sb_ze_zes_bysize = ...
pl_sb_C_is_ides_complete = ...
pl_sb_C_is_ides_endings = ...
pl_sb_C_is_ides = ...
pl_sb_C_is_ides_list = ...
pl_sb_C_a_ata_list = ...
pl_sb_U_a_ae_list = ...
pl_sb_C_a_ae_list = ...
pl_sb_C_en_ina_list = ...
pl_sb_U_um_a_list = ...
pl_sb_C_um_a_list = ...
pl_sb_U_us_i_list = ...
pl_sb_C_us_i_list = ...
pl_sb_C_us_us = ...
pl_sb_C_us_us_bysize = ...
pl_sb_U_on_a_list = ...
pl_sb_C_on_a_list = ...
pl_sb_C_o_i = ...
pl_sb_C_o_i_bysize = ...
si_sb_C_o_i_bysize = ...
pl_sb_C_o_i_stems = ...
pl_sb_U_o_os_complete = ...
si_sb_U_o_os_complete = ...
pl_sb_U_o_os_endings = ...
pl_sb_U_o_os_bysize = ...
si_sb_U_o_os_bysize = ...
pl_sb_U_ch_chs_list = ...
pl_sb_U_ex_ices_list = ...
pl_sb_U_ix_ices_list = ...
pl_sb_C_ex_ices_list = ...
pl_sb_C_ix_ices_list = ...
pl_sb_C_i_list = ...
pl_sb_C_im_list = ...
pl_sb_U_man_mans_list = ...
pl_sb_U_man_mans_caps_list = ...
pl_sb_uninflected_s_complete = ...
pl_sb_uninflected_s_endings = ...
pl_sb_uninflected_s = ...
pl_sb_uninflected_herd = ...
pl_sb_uninflected_complete = ...
pl_sb_uninflected_caps = ...
pl_sb_uninflected_endings = ...
pl_sb_uninflected_bysize = ...
pl_sb_singular_s_complete = ...
pl_sb_singular_s_endings = ...
pl_sb_singular_s_bysize = ...
si_sb_singular_s_complete = ...
si_sb_singular_s_endings = ...
si_sb_singular_s_bysize = ...
pl_sb_singular_s_es = ...
pl_sb_singular_s = ...
si_sb_ois_oi_case = ...
si_sb_uses_use_case = ...
si_sb_uses_use = ...
si_sb_ies_ie_case = ...
si_sb_ies_ie = ...
si_sb_oes_oe_case = ...
si_sb_oes_oe = ...
si_sb_z_zes = ...
si_sb_zzes_zz = ...
si_sb_ches_che_case = ...
si_sb_ches_che = ...
si_sb_xes_xe = ...
si_sb_sses_sse_case = ...
si_sb_sses_sse = ...
si_sb_ves_ve_case = ...
si_sb_ves_ve = ...
plverb_special_s = ...
pl_sb_postfix_adj = ...
pl_sb_postfix_adj_stems = ...
si_sb_es_is = ...
pl_prep_list = ...
pl_prep_list_da = ...
pl_prep_bysize = ...
pl_prep = ...
pl_sb_prep_dual_compound = ...
singular_pronoun_genders = ...
pl_pron_nom = ...
si_pron = ...
pl_pron_acc = ...
pl_pron_acc_keys = ...
pl_pron_acc_keys_bysize = ...
si_pron_acc_keys = ...
si_pron_acc_keys_bysize = ...

def get_si_pron(thecase, word, gender): ...

plverb_irregular_pres = ...
plverb_ambiguous_pres = ...
plverb_ambiguous_pres_keys = ...
plverb_irregular_non_pres = ...
plverb_ambiguous_non_pres = ...
pl_v_oes_oe = ...
pl_v_oes_oe_endings_size4 = ...
pl_v_oes_oe_endings_size5 = ...
pl_count_zero = ...
pl_count_one = ...
pl_adj_special = ...
pl_adj_special_keys = ...
pl_adj_poss = ...
pl_adj_poss_keys = ...
A_abbrev = ...
A_y_cons = ...
A_explicit_a = ...
A_explicit_an = ...
A_ordinal_an = ...
A_ordinal_a = ...
nth = ...
ordinal = ...
ordinal_suff = ...
unit = ...
teen = ...
ten = ...
mill = ...
def_classical = ...
all_classical = ...
no_classical = ...
string_to_constant = ...

class engine:
    def __init__(self) -> None: ...

    deprecated_methods = ...
    def __getattr__(self, meth): ...
    def defnoun(self, singular, plural):  # -> Literal[1]:
        """
        Set the noun plural of singular to plural.

        """
        ...
    def defverb(self, s1, p1, s2, p2, s3, p3):  # -> Literal[1]:
        """
        Set the verb plurals for s1, s2 and s3 to p1, p2 and p3 respectively.

        Where 1, 2 and 3 represent the 1st, 2nd and 3rd person forms of the verb.

        """
        ...
    def defadj(self, singular, plural):  # -> Literal[1]:
        """
        Set the adjective plural of singular to plural.

        """
        ...
    def defa(self, pattern):  # -> Literal[1]:
        """
        Define the indefinite article as 'a' for words matching pattern.

        """
        ...
    def defan(self, pattern):  # -> Literal[1]:
        """
        Define the indefinite article as 'an' for words matching pattern.

        """
        ...
    def checkpat(self, pattern):  # -> None:
        """
        check for errors in a regex pattern
        """
        ...
    def checkpatplural(self, pattern):  # -> None:
        """
        check for errors in a regex replace pattern
        """
        ...
    def ud_match(self, word, wordlist): ...
    def classical(self, **kwargs):  # -> None:
        """
        turn classical mode on and off for various categories

        turn on all classical modes:
        classical()
        classical(all=True)

        turn on or off specific claassical modes:
        e.g.
        classical(herd=True)
        classical(names=False)

        By default all classical modes are off except names.

        unknown value in args or key in kwargs raises
        exception: UnknownClasicalModeError

        """
        ...
    def num(self, count=..., show=...):  # -> str:
        """
        Set the number to be used in other method calls.

        Returns count.

        Set show to False to return '' instead.

        """
        ...
    def gender(self, gender):  # -> None:
        """
        set the gender for the singular of plural pronouns

        can be one of:
        'neuter'                ('they' -> 'it')
        'feminine'              ('they' -> 'she')
        'masculine'             ('they' -> 'he')
        'gender-neutral'        ('they' -> 'they')
        'feminine or masculine' ('they' -> 'she or he')
        'masculine or feminine' ('they' -> 'he or she')
        """
        ...
    def inflect(self, text):
        """
        Perform inflections in a string.

        e.g. inflect('The plural of cat is plural(cat)') returns
        'The plural of cat is cats'

        can use plural, plural_noun, plural_verb, plural_adj,
        singular_noun, a, an, no, ordinal, number_to_words,
        and prespart

        """
        ...
    def postprocess(self, orig, inflected): ...
    def partition_word(self, text): ...
    def plural(self, text, count=...):  # -> str:
        """
        Return the plural of text.

        If count supplied, then return text if count is one of:
            1, a, an, one, each, every, this, that
        otherwise return the plural.

        Whitespace at the start and end is preserved.

        """
        ...
    def plural_noun(self, text, count=...):  # -> str:
        """
        Return the plural of text, where text is a noun.

        If count supplied, then return text if count is one of:
            1, a, an, one, each, every, this, that
        otherwise return the plural.

        Whitespace at the start and end is preserved.

        """
        ...
    def plural_verb(self, text, count=...):  # -> str:
        """
        Return the plural of text, where text is a verb.

        If count supplied, then return text if count is one of:
            1, a, an, one, each, every, this, that
        otherwise return the plural.

        Whitespace at the start and end is preserved.

        """
        ...
    def plural_adj(self, text, count=...):  # -> str:
        """
        Return the plural of text, where text is an adjective.

        If count supplied, then return text if count is one of:
            1, a, an, one, each, every, this, that
        otherwise return the plural.

        Whitespace at the start and end is preserved.

        """
        ...
    def compare(self, word1, word2):  # -> Literal['eq', 'p:s', 's:p', 'p:p', False]:
        """
        compare word1 and word2 for equality regardless of plurality

        return values:
        eq - the strings are equal
        p:s - word1 is the plural of word2
        s:p - word2 is the plural of word1
        p:p - word1 and word2 are two different plural forms of the one word
        False - otherwise

        """
        ...
    def compare_nouns(
        self, word1, word2
    ):  # -> Literal['eq', 'p:s', 's:p', 'p:p', False]:
        """
        compare word1 and word2 for equality regardless of plurality
        word1 and word2 are to be treated as nouns

        return values:
        eq - the strings are equal
        p:s - word1 is the plural of word2
        s:p - word2 is the plural of word1
        p:p - word1 and word2 are two different plural forms of the one word
        False - otherwise

        """
        ...
    def compare_verbs(
        self, word1, word2
    ):  # -> Literal['eq', 'p:s', 's:p', 'p:p', False]:
        """
        compare word1 and word2 for equality regardless of plurality
        word1 and word2 are to be treated as verbs

        return values:
        eq - the strings are equal
        p:s - word1 is the plural of word2
        s:p - word2 is the plural of word1
        p:p - word1 and word2 are two different plural forms of the one word
        False - otherwise

        """
        ...
    def compare_adjs(
        self, word1, word2
    ):  # -> Literal['eq', 'p:s', 's:p', 'p:p', False]:
        """
        compare word1 and word2 for equality regardless of plurality
        word1 and word2 are to be treated as adjectives

        return values:
        eq - the strings are equal
        p:s - word1 is the plural of word2
        s:p - word2 is the plural of word1
        p:p - word1 and word2 are two different plural forms of the one word
        False - otherwise

        """
        ...
    def singular_noun(self, text, count=..., gender=...):  # -> str | Literal[False]:
        """
        Return the singular of text, where text is a plural noun.

        If count supplied, then return the singular if count is one of:
            1, a, an, one, each, every, this, that or if count is None
        otherwise return text unchanged.

        Whitespace at the start and end is preserved.

        """
        ...
    def get_count(self, count=...): ...
    def a(self, text, count=...):  # -> str:
        """
        Return the appropriate indefinite article followed by text.

        The indefinite article is either 'a' or 'an'.

        If count is not one, then return count followed by text
        instead of 'a' or 'an'.

        Whitespace at the start and end is preserved.

        """
        ...
    an = ...
    def no(self, text, count=...):  # -> str:
        """
        If count is 0, no, zero or nil, return 'no' followed by the plural
        of text.

        If count is one of:
            1, a, an, one, each, every, this, that
        return count followed by text.

        Otherwise return count follow by the plural of text.

        In the return value count is always followed by a space.

        Whitespace at the start and end is preserved.

        """
        ...
    def present_participle(self, word):  # -> str | LiteralString:
        """
        Return the present participle for word.

        word is the 3rd person singular verb.

        """
        ...
    def ordinal(self, num):  # -> str:
        """
        Return the ordinal of num.

        num can be an integer or text

        e.g. ordinal(1) returns '1st'
        ordinal('one') returns 'first'

        """
        ...
    def millfn(self, ind=...): ...
    def unitfn(self, units, mindex=...): ...
    def tenfn(self, tens, units, mindex=...): ...
    def hundfn(self, hundreds, tens, units, mindex): ...
    def group1sub(self, mo): ...
    def group1bsub(self, mo): ...
    def group2sub(self, mo): ...
    def group3sub(self, mo): ...
    def hundsub(self, mo): ...
    def tensub(self, mo): ...
    def unitsub(self, mo): ...
    def enword(self, num, group): ...
    def blankfn(self, mo):  # -> Literal['']:
        """do a global blank replace
        TODO: surely this can be done with an option to re.sub
              rather than this fn
        """
        ...
    def commafn(self, mo):  # -> Literal[',']:
        """do a global ',' replace
        TODO: surely this can be done with an option to re.sub
              rather than this fn
        """
        ...
    def spacefn(self, mo):  # -> Literal[' ']:
        """do a global ' ' replace
        TODO: surely this can be done with an option to re.sub
              rather than this fn
        """
        ...
    def number_to_words(
        self,
        num,
        wantlist=...,
        group=...,
        comma=...,
        andword=...,
        zero=...,
        one=...,
        decimal=...,
        threshold=...,
    ):
        """
        Return a number in words.

        group = 1, 2 or 3 to group numbers before turning into words
        comma: define comma
        andword: word for 'and'. Can be set to ''.
            e.g. "one hundred and one" vs "one hundred one"
        zero: word for '0'
        one: word for '1'
        decimal: word for decimal point
        threshold: numbers above threshold not turned into words

        parameters not remembered from last call. Departure from Perl version.
        """
        ...
    def join(
        self, words, sep=..., sep_spaced=..., final_sep=..., conj=..., conj_spaced=...
    ):  # -> str:
        """
        Join words into a list.

        e.g. join(['ant', 'bee', 'fly']) returns 'ant, bee, and fly'

        options:
        conj: replacement for 'and'
        sep: separator. default ',', unless ',' is in the list then ';'
        final_sep: final separator. default ',', unless ',' is in the list then ';'
        conj_spaced: boolean. Should conj have spaces around it

        """
        ...
