"""
This type stub file was generated by pyright.
"""
from __future__ import annotations

import os
import typing
from abc import ABC, abstractmethod
from pathlib import Path
from typing import List, Optional, Pattern, Tuple, Union

from snakemake import sourcecache
from snakemake.io import InputFiles, OutputFiles, Params
from snakemake.sourcecache import SourceCache

__author__ = ...
__copyright__ = ...
__email__ = ...
__license__ = ...
PY_PREAMBLE_RE = ...
PathLike = Union[str, Path, os.PathLike]

class Snakemake:
    def __init__(
        self,
        input_,
        output,
        params,
        wildcards,
        threads,
        resources,
        log,
        config,
        rulename,
        bench_iteration,
        scriptdir=...,
    ) -> None: ...
    input: "InputFiles[str]"
    output: "OutputFiles[str]"
    params: "Params[str]"
    def log_fmt_shell(self, stdout=..., stderr=..., append=...):  # -> str:
        """
        Return a shell redirection string to be used in `shell()` calls

        This function allows scripts and wrappers to support optional `log` files
        specified in the calling rule.  If no `log` was specified, then an
        empty string "" is returned, regardless of the values of `stdout`,
        `stderr`, and `append`.

        Parameters
        ---------

        stdout : bool
            Send stdout to log

        stderr : bool
            Send stderr to log

        append : bool
            Do not overwrite the log file. Useful for sending an output of
            multiple commands to the same log. Note however that the log will
            not be truncated at the start.

        The following table describes the output:

        -------- -------- -------- ----- -------------
        stdout   stderr   append   log   return value
        -------- -------- -------- ----- ------------
        True     True     True     fn    >> fn 2>&1
        True     False    True     fn    >> fn
        False    True     True     fn    2>> fn
        True     True     False    fn    > fn 2>&1
        True     False    False    fn    > fn
        False    True     False    fn    2> fn
        any      any      any      None  ""
        -------- -------- -------- ----- -----------
        """
        ...

class REncoder:
    """Encoding Python data structures into R."""

    @classmethod
    def encode_numeric(cls, value): ...
    @classmethod
    def encode_value(cls, value): ...
    @classmethod
    def encode_list(cls, l): ...
    @classmethod
    def encode_items(cls, items): ...
    @classmethod
    def encode_dict(cls, d): ...
    @classmethod
    def encode_namedlist(cls, namedlist): ...

class JuliaEncoder:
    """Encoding Python data structures into Julia."""

    @classmethod
    def encode_value(cls, value): ...
    @classmethod
    def encode_list(cls, l): ...
    @classmethod
    def encode_items(cls, items): ...
    @classmethod
    def encode_positional_items(cls, namedlist): ...
    @classmethod
    def encode_dict(cls, d): ...
    @classmethod
    def encode_namedlist(cls, namedlist): ...

class BashEncoder:
    """bash docs for associative arrays - https://www.gnu.org/software/bash/manual/html_node/Arrays.html#Arrays"""

    def __init__(
        self, namedlists: List[str] = ..., dicts: List[str] = ..., prefix: str = ...
    ) -> None:
        """namedlists is a list of strings indicating the snakemake object's member
        variables which are encoded as Namedlist.
        dicts is a list of strings indicating the snakemake object's member variables
        that are encoded as dictionaries.
        Prefix is the prefix for the bash variable name(s) e.g., snakemake_input
        """
        ...
    def encode_snakemake(self, smk: Snakemake) -> str:
        """Turn a snakemake object into a collection of bash associative arrays"""
        ...
    @staticmethod
    def dict_to_aa(d: dict) -> str:
        """Converts a dictionary to an associative array"""
        ...
    @classmethod
    def encode_namedlist(cls, named_list) -> str:
        """Convert a namedlist into a bash associative array
        This produces the array component of the variable.
        e.g. ( [var1]=val1 [var2]=val2 )
        to make it a correct bash associative array, you need to name it with
        name=<output of this method>
        """
        ...

class ScriptBase(ABC):
    editable = ...
    def __init__(
        self,
        path,
        cache_path: typing.Optional[str],
        source,
        basedir,
        input_,
        output,
        params,
        wildcards,
        threads,
        resources,
        log,
        config,
        rulename,
        conda_env,
        conda_base_path,
        container_img,
        singularity_args,
        env_modules,
        bench_record,
        jobid,
        bench_iteration,
        cleanup_scripts,
        shadow_dir,
        is_local,
    ) -> None: ...
    def evaluate(self, edit=...): ...
    @property
    def local_path(self): ...
    @abstractmethod
    def get_preamble(self): ...
    @abstractmethod
    def write_script(self, preamble, fd): ...
    @abstractmethod
    def execute_script(self, fname, edit=...): ...

class PythonScript(ScriptBase):
    @staticmethod
    def generate_preamble(
        path,
        cache_path: typing.Optional[str],
        source,
        basedir,
        input_,
        output,
        params,
        wildcards,
        threads,
        resources,
        log,
        config,
        rulename,
        conda_env,
        container_img,
        singularity_args,
        env_modules,
        bench_record,
        jobid,
        bench_iteration,
        cleanup_scripts,
        shadow_dir,
        is_local,
        preamble_addendum=...,
    ): ...
    def get_preamble(self): ...
    def write_script(self, preamble, fd): ...
    def execute_script(self, fname, edit=...): ...

class RScript(ScriptBase):
    @staticmethod
    def generate_preamble(
        path,
        source,
        basedir,
        input_,
        output,
        params,
        wildcards,
        threads,
        resources,
        log,
        config,
        rulename,
        conda_env,
        container_img,
        singularity_args,
        env_modules,
        bench_record,
        jobid,
        bench_iteration,
        cleanup_scripts,
        shadow_dir,
        preamble_addendum=...,
    ): ...
    def get_preamble(self): ...
    def write_script(self, preamble, fd): ...
    def execute_script(self, fname, edit=...): ...

class RMarkdown(ScriptBase):
    def get_preamble(self): ...
    def write_script(self, preamble, fd): ...
    def execute_script(self, fname, edit=...): ...

class JuliaScript(ScriptBase):
    def get_preamble(self): ...
    def write_script(self, preamble, fd): ...
    def execute_script(self, fname, edit=...): ...

class RustScript(ScriptBase):
    @staticmethod
    def generate_preamble(
        path,
        source,
        basedir,
        input_,
        output,
        params,
        wildcards,
        threads,
        resources,
        log,
        config,
        rulename,
        conda_env,
        container_img,
        singularity_args,
        env_modules,
        bench_record,
        jobid,
        bench_iteration,
        cleanup_scripts,
        shadow_dir,
        is_local,
        preamble_addendum=...,
    ): ...
    def get_preamble(self): ...
    def write_script(self, preamble, fd): ...
    def execute_script(self, fname, edit=...): ...
    def combine_preamble_and_source(self, preamble: str) -> str:
        """The manifest info needs to be moved to before the preamble.
        Also, because rust-scipt relies on inner docs, there can't be an empty line
        between the manifest and preamble.
        """
        ...
    @staticmethod
    def default_dependencies() -> str: ...
    @staticmethod
    def default_features() -> str: ...
    @staticmethod
    def extract_manifest(source: str) -> Tuple[str, str]: ...

class BashScript(ScriptBase):
    @staticmethod
    def generate_preamble(
        path,
        source,
        basedir,
        input_,
        output,
        params,
        wildcards,
        threads,
        resources,
        log,
        config,
        rulename,
        conda_env,
        container_img,
        singularity_args,
        env_modules,
        bench_record,
        jobid,
        bench_iteration,
        cleanup_scripts,
        shadow_dir,
        is_local,
    ) -> str: ...
    def get_preamble(self): ...
    def write_script(self, preamble, fd): ...
    def combine_preamble_and_source(self, preamble: str): ...
    def execute_script(self, fname, edit=...): ...

def strip_re(regex: Pattern, s: str) -> Tuple[str, str]:
    """Strip a substring matching a regex from a string and return the stripped part
    and the remainder of the original string.
    Returns an empty string and the original string if the regex is not found
    """
    ...

def get_source(
    path, sourcecache: sourcecache.SourceCache, basedir=..., wildcards=..., params=...
): ...
def get_language(source_file, source): ...
def script(
    path,
    basedir,
    input,
    output,
    params,
    wildcards,
    threads,
    resources,
    log,
    config,
    rulename,
    conda_env,
    conda_base_path,
    container_img,
    singularity_args,
    env_modules,
    bench_record,
    jobid,
    bench_iteration,
    cleanup_scripts,
    shadow_dir,
    runtime_sourcecache_path,
):  # -> None:
    """
    Load a script from the given basedir + path and execute it.
    """
    ...
